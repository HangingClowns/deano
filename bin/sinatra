require 'active_support/core_ext'
require 'fileutils'

$template_dir = File.expand_path(File.join("..", "template"), File.dirname(__FILE__))

command = ARGV[0]

class Command

  def self.command
    nil
  end

  def self.commands
    @commands ||= []
  end

  def self.inherited(klass)
    self.commands << klass
  end

  def cmd(command)
    puts command
    system command
  end

end

class NameCommand < Command
  include FileUtils

  attr_accessor :args, :name

  def self.inherited(klass)
    Command.inherited(klass)
  end

  def underscored
    self.name.underscore
  end

  def classified
    self.name.classify
  end

  def initialize(args)
    self.args = args
    self.name = ARGV[1]
  end

  def clean_string(f)
    f.gsub($template_dir, @app_dir).gsub("my_app", self.underscored).gsub("MyApp", self.classified)
  end

end

class NewProjectGenerator < NameCommand

  def self.command
    "new"
  end

  def self.help
    "name"
  end

  def initialize(*args)
    super
    @app_dir = File.expand_path(File.join(pwd, self.underscored))
  end

  def classified
    "#{self.name.classify}App"
  end

  def call
    mkdir self.underscored, verbose: true
    Dir[File.expand_path(File.join("**", "*"), $template_dir)].each do |f|
      if File.directory?(f)
        mkdir_p clean_string(f), verbose: true
      else
        mkdir_p clean_string(File.dirname(f)), verbose: true
        File.open(clean_string(f), 'w') do |file|
          file.puts clean_string(File.read(f))
        end
      end
    end
  end

end

class AppGenerator < NameCommand

  def self.command
    "generate:app"
  end

  def self.help
    "app_name"
  end

  def initialize(*args)
    super
    @app_dir = File.expand_path(pwd)
  end

  def classified
    "#{self.name.classify}App"
  end

  def call
    # mkdir self.underscored, verbose: true
    %w{apps spec/apps}.each do |dir|
      Dir[File.expand_path(File.join(dir, "**", "*"), $template_dir)].each do |f|
        if File.directory?(f)
          mkdir_p clean_string(f), verbose: true
        else
          mkdir_p clean_string(File.dirname(f)), verbose: true
          File.open(clean_string(f), 'w') do |file|
            file.puts clean_string(File.read(f))
          end
        end
      end
    end
    File.open(File.expand_path(File.join(@app_dir, "config.ru")), "a") do |file|
      file.puts <<-EOF
map "/#{self.underscored}" do
  run #{self.classified}
end
      EOF
    end

    path = File.expand_path(File.join(@app_dir, "spec", "apps", "#{self.underscored}_spec.rb"))
    mkdir_p File.dirname(path), verbose: true
    File.open(path, 'w') do |file|
      file.puts <<-EOF
require 'spec_helper'

describe #{self.classified} do
  
  it "does something"

end
      EOF
    end
  end

end

class AppDestroyer < NameCommand

  def self.command
    "destroy:app"
  end

  def self.help
    "app_name"
  end
  
  def initialize(*args)
    super
    @app_dir = File.expand_path(pwd)
  end

  def classified
    "#{self.name.classify}App"
  end

  def call
    path = File.expand_path(File.join(@app_dir, "apps", "#{self.underscored}.rb"))
    begin
      rm path, verbose: true
    rescue Errno::ENOENT => e
    end
    path = File.expand_path(File.join(@app_dir, "apps", "views", self.underscored))
    begin
      rm_r path, verbose: true
    rescue Errno::ENOENT => e
    end
    path = File.expand_path(File.join(@app_dir, "spec", "apps", "#{self.underscored}_spec.rb"))
    begin
      rm path, verbose: true
    rescue Errno::ENOENT => e
    end

    path = File.expand_path(File.join(@app_dir, "config.ru"))
    old = File.read(path)
    File.open(path, "w") do |file|
      map = <<-EOF
map "/#{self.underscored}" do
  run #{self.classified}
end
      EOF
      file.puts old.gsub(map, "")
    end
  end

end

class ModelGenerator < NameCommand

  def self.command
    "generate:model"
  end

  def self.help
    "model_name"
  end

  def initialize(*args)
    super
    @app_dir = File.expand_path(pwd)
  end

  def call
    path = File.expand_path(File.join(@app_dir, "models", "#{self.underscored}.rb"))
    mkdir_p File.dirname(path), verbose: true
    File.open(path, 'w') do |file|
      file.puts <<-EOF
class #{self.classified}
  include Mongoid::Document
  include Mongoid::Timestamps

end
      EOF
    end

    path = File.expand_path(File.join(@app_dir, "spec", "models", "#{self.underscored}_spec.rb"))
    mkdir_p File.dirname(path), verbose: true
    File.open(path, 'w') do |file|
      file.puts <<-EOF
require 'spec_helper'

describe #{self.classified} do
  
  it "does something"

end
      EOF
    end
  end

end

class ModelDestroyer < NameCommand

  def self.command
    "destroy:model"
  end

  def self.help
    "model_name"
  end
  
  def initialize(*args)
    super
    @app_dir = File.expand_path(pwd)
  end

  def call
    path = File.expand_path(File.join(@app_dir, "models", "#{self.underscored}.rb"))
    begin
      rm path, verbose: true
    rescue Errno::ENOENT => e
    end
    path = File.expand_path(File.join(@app_dir, "spec", "models", "#{self.underscored}_spec.rb"))
    begin
      rm path, verbose: true
    rescue Errno::ENOENT => e
    end
  end

end

class EnvCommand < Command
  include FileUtils

  attr_accessor :args, :env

  def self.inherited(klass)
    Command.inherited(klass)
  end

  def initialize(args)
    self.args = args
    @app_dir = File.expand_path(pwd)
    self.env = args[1] || "development"
    ENV["RACK_ENV"] = self.env
  end

end

class ConsoleCommand < EnvCommand

  def self.command
    "console"
  end

  def self.help
    "[environment]\t\t# default: development"
  end

  def call
    path = File.expand_path(File.join(@app_dir, "setup.rb"))
    cmd "pry -r #{path}"
  end

end

class StartCommand < EnvCommand

  def self.command
    "start"
  end

  def self.help
    "[environment]\t\t# default: development"
  end

  def call
    path = File.expand_path(File.join(@app_dir, "Procfile.#{self.env}"))
    if File.exists?(path)
      cmd "bundle exec foreman start -f #{path}"
    else
      path = File.expand_path(File.join(@app_dir, "Procfile"))
      cmd "bundle exec foreman start -f #{path}"
    end
  end

end

Command.commands.each do |klass|
  if klass.command == command
    klass.new(ARGV).call
    exit(0)
  end
end
Command.commands.each do |klass|
  if klass.respond_to?(:help)
    puts "sinatra #{klass.command} #{klass.help}"
  end
end

# case command
# when 'help'
#   Command.commands.each do |klass|
#     if klass.respond_to?(:help)
#       puts "sinatra #{klass.command} #{klass.help}"
#     end
#   end
# when 'new'
#   NewProjectGenerator.new(ARGV).call
# when 'generate:app'
#   AppGenerator.new(ARGV).call
# when 'destroy:app'
#   AppDestroyer.new(ARGV).call
# when 'generate:model'
#   ModelGenerator.new(ARGV).call
# when 'destroy:model'
#   ModelDestroyer.new(ARGV).call
# when 'console'
#   ConsoleCommand.new(ARGV).call
# when 'start'
#   StartCommand.new(ARGV).call
# end